package org.synth.intercept;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.EmptyStackException;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Type;
import org.objectweb.asm.util.CheckClassAdapter;
import org.objectweb.asm.util.TraceClassVisitor;

/**
 *A few tests of the instrumentation process.
 */
public class TestInstrumentation extends TestCase
{
    /**
     * Writes the generated bytecodes out to a file for inspection as well as wrapping the
     * ClassWriter in a TraceClassVisitor to print debugging information.
     */
    public static final boolean DEBUG = false;

    /**
     * The input class for the intercepting transformation.
     */
    public static final String TEST_INTERCEPTING_DATA_RESOURCE =
        "/org/synth/intercept/data/TestInterceptingData.class";

    /**
     * The input class for the wrapping transformation.
     */
    public static final String TEST_WRAPPING_DATA_RESOURCE =
        "/org/synth/intercept/data/TestWrappingData.class";

    /**
     * Tests just the wrapping transformation.
     *
     * @throws Exception
     */
    public void testWrapping() throws Exception
    {
        final ClassReader reader = new ClassReader(TestInstrumentation.class.getResourceAsStream(TestInstrumentation.TEST_WRAPPING_DATA_RESOURCE));
        final ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);
        final NativeWrappingClassAdapter adapter =
            new NativeWrappingClassAdapter(TestInstrumentation.getClassAdapter(writer),
                                           Type.getType("Lorg/synth/intercept/data/TestWrappingData;"));
        reader.accept(adapter, 0);
        final byte[] classBytes = writer.toByteArray();
        TestInstrumentation.writeToFile(classBytes, "TestWrappingData.class");
        try
        {
            final TestClassLoader loader = new TestClassLoader();
            final Class<?> c = loader.testClass("org.synth.intercept.data.TestWrappingData", classBytes);
            final Object data = c.newInstance();
            c.getMethod("instanceObject").invoke(data);
        }
        catch (final InvocationTargetException expected)
        {
            Assert.assertEquals("Incorrect target exception type",
                         UnsatisfiedLinkError.class, expected.getTargetException().getClass());
        }
        catch (final Throwable t)
        {
            t.printStackTrace(System.out);
            Assert.fail("Unknown exception thrown during loading of instrumented class bytes");
        }
    }

    /**
     * Tests just the intercepting transformation.
     *
     * @throws Exception
     */
    public void testIntercepting() throws Exception
    {
        final ClassReader reader = new ClassReader(TestInstrumentation.class.getResourceAsStream(TestInstrumentation.TEST_INTERCEPTING_DATA_RESOURCE));
        final ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);
        final NativeInterceptingClassAdapter adapter =
            new NativeInterceptingClassAdapter(TestInstrumentation.getClassAdapter(writer),
                                               Type.getType("Lorg/synth/intercept/data/TestIterceptingData;"));
        reader.accept(adapter, 0);
        final byte[] classBytes = writer.toByteArray();
        TestInstrumentation.writeToFile(classBytes,"DebugTestInterceptingData.class");
        final TestClassLoader loader = new TestClassLoader();
        final Class<?> c = loader.testClass("org.synth.intercept.data.TestInterceptingData", classBytes);
        final boolean[] toAssert = new boolean[] { false };
        NativeInvocationHandler.registerHandler(c, new InvocationHandler()
        {
            @Override
            public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable
            {
                toAssert[0] = true;
                return null;
            }
        });
        final Object data = c.newInstance();
        c.getMethod("instanceObject").invoke(data);
        Assert.assertTrue(toAssert[0]);
    }

    /**
     * Tests both the wrapping an intercepting transformations.
     *
     * @throws Exception
     */
    public void testWrappingAndIntercepting() throws Exception
    {
        ClassReader reader = new ClassReader(TestInstrumentation.class.getResourceAsStream(TestInstrumentation.TEST_WRAPPING_DATA_RESOURCE));
        ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);
        final NativeWrappingClassAdapter adapterWrapper =
            new NativeWrappingClassAdapter(TestInstrumentation.getClassAdapter(writer),
                                           Type.getType("Lorg/synth/intercept/data/TestWrappingData;"));
        reader.accept(adapterWrapper, 0);
        byte[] classBytes = writer.toByteArray();
        reader = new ClassReader(classBytes);
        writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);
        final NativeInterceptingClassAdapter adapterInterceptor =
            new NativeInterceptingClassAdapter(TestInstrumentation.getClassAdapter(writer),
                                               Type.getType("Lorg/synth/intercept/data/TestWrappingData;"));
        reader.accept(adapterInterceptor, 0);
        classBytes = writer.toByteArray();
        final TestClassLoader loader = new TestClassLoader();
        final Class<?> c = loader.testClass("org.synth.intercept.data.TestWrappingData", classBytes);
        final boolean[] toAssert = new boolean[] { false };
        NativeInvocationHandler.registerHandler(c, new InvocationHandler()
        {
            @Override
            public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable
            {
                toAssert[0] = true;
                if (args.length != 3)
                    Assert.fail("Invalid argument length");
                Assert.assertEquals("testinput", args[0].toString());
                Assert.assertTrue(Arrays.equals(new float[] { 1.3f, 2.9f, 3 }, (float[])args[1]));
                Assert.assertEquals("Hello, world!", args[2]);
                return new int[] { 1, 2, 3};
            }
        });
        final Object data = c.newInstance();
        final int[] result = (int[])c.getMethod("instanceIntArray", Object.class, float[].class, String.class).
            invoke(data, new StringBuilder("testinput"), new float[] { 1.3f, 2.9f, 3 }, "Hello, world!");
        Assert.assertTrue(toAssert[0]);
        Assert.assertTrue(Arrays.equals(new int[] { 1, 2, 3}, result));
    }

    /**
     * Tests both the wrapping and intercepting transformations work correctly when the
     * {@link InvocationHandler} throws a declared exception.
     *
     * @throws Exception
     */
    public void testWrappingAndInterceptingWhenThrowingDeclaredException() throws Exception
    {
        ClassReader reader = new ClassReader(TestInstrumentation.class.getResourceAsStream(TestInstrumentation.TEST_WRAPPING_DATA_RESOURCE));
        ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);
        final NativeWrappingClassAdapter adapterWrapper =
            new NativeWrappingClassAdapter(TestInstrumentation.getClassAdapter(writer),
                                           Type.getType("Lorg/synth/intercept/data/TestWrappingData;"));
        reader.accept(adapterWrapper, 0);
        byte[] classBytes = writer.toByteArray();
        reader = new ClassReader(classBytes);
        writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);
        final NativeInterceptingClassAdapter adapterInterceptor =
            new NativeInterceptingClassAdapter(TestInstrumentation.getClassAdapter(writer),
                                               Type.getType("Lorg/synth/intercept/data/TestWrappingData;"));
        reader.accept(adapterInterceptor, 0);
        classBytes = writer.toByteArray();
        final TestClassLoader loader = new TestClassLoader();
        final Class<?> c = loader.testClass("org.synth.intercept.data.TestWrappingData", classBytes);
        final boolean[] toAssert = new boolean[] { false };
        NativeInvocationHandler.registerHandler(c, new InvocationHandler()
        {
            @Override
            public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable
            {
                toAssert[0] = true;
                throw new EmptyStackException();
            }
        });
        final Object data = c.newInstance();
        try
        {
            c.getMethod("instanceIntArray", Object.class, float[].class, String.class).
                invoke(data, new StringBuilder("testinput"), new float[] { 1.3f, 2.9f, 3 }, "Hello, world!");
            Assert.fail("Expected exception not thrown...");
        }
        catch (final InvocationTargetException e)
        {
            Assert.assertTrue(e.getTargetException() instanceof EmptyStackException);
        }
        Assert.assertTrue(toAssert[0]);
    }

    /**
     * add a layer of indirection to allow easy wrapping of the class wrapper for debugging purposes.
     */
    static ClassVisitor getClassAdapter(final ClassWriter cw)
    {
        return TestInstrumentation.DEBUG ?
            new TraceClassVisitor(new CheckClassAdapter(cw), new PrintWriter(System.out)) : cw;
    }

    /**
     * utility method to write the generated bytecodes out to a file.
     *
     * @param bytes the bytecodes
     * @param file the file
     * @throws IOException when writing fails for some reason.
     */
    static void writeToFile(final byte[] bytes, final String file) throws IOException
    {
        final File f = new File(file);
        if (f.exists())
            f.delete();
        if (TestInstrumentation.DEBUG)
        {
            OutputStream out = null;
            try
            {
                out = new FileOutputStream(f);
                out.write(bytes);
            }
            finally
            {
                if (out != null)
                    try { out.close(); } catch (final IOException ignored) {}
            }
        }
    }

    /**
     * A simple classloader to load the generated bytecodes. This allows for testing bytecode
     * generation without running this test with the -javaagent VM flag.
     */
    static class TestClassLoader extends ClassLoader
    {
        public Class<?> testClass(final String name, final byte[] bytes)
        {
            return this.defineClass(name, bytes, 0, bytes.length);
        }
    }
}