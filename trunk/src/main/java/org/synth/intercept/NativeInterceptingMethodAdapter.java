package org.synth.intercept;

import java.lang.instrument.ClassFileTransformer;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.ClassAdapter;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodAdapter;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.commons.GeneratorAdapter;
import org.objectweb.asm.commons.Method;

/**
 * The {@link MethodAdapter} that handles the majority of the bytecode generation for intercepting
 * methods that were originally native. This class expects to operate on methods created by the
 * {@link NativeWrappingMethodAdapter}.
 *
 * For example, if the original native method was defined as:
 * <code>
 * public native Object[] theNativeMethod(int i, float j, String k) throws IOException;
 * </code>
 * Then the wrapped method will be equivalent to the source:
 * <code>
 * public Object[] theNativeMethod(int i, float j, String k) throws IOException
 * {
 *     return this.wrapped_$$_theNativeMethod(i, j, k);
 * }
 *
 * public native Object[] wrapped_$$_theNativeMethod(int i, float j, String k) throws IOException;
 * </code>
 * And the bytecode generated by this method will be equivalent to:
 * <code>
 * public Object[] theNativeMethod(int i, float j, String k) throws IOException
 * {
 *     try
 *     {
 *         // Calls the interface that will locate the appropriate registered InvocationHandler
 *         return NativeInvocationHandler.handleObject(
 *             TheClass.class, // the class that declared the native method
 *             Object[].class, // the return type
 *             "theNativeMethod", // the name of the native method
 *             new Class[] { int.class, float.class, String.class }, // the argument types of the intercepted method
 *             new Object[] { i, j, k }); // the actual arguments passed to the method.
 *     }
 *     catch (Throwable t)
 *     {
 *         // Since the native method declared that it can throw an IOException, it's legal for the
 *         // interceptor to throw that exception.
 *         if (t instanceof IOException)
 *            throw (IOException)t;
 *         // And it's always legal to throw a RuntimeException
 *         if (t instanceof RuntimeException)
 *            throw (RuntimeException)t;
 *         // The
 *         throw new IllegalStateException("Unexpected exception thrown in interceptor", t);
 *     }
 * }
 */
public class NativeInterceptingMethodAdapter extends GeneratorAdapter
{
    /**
     * An array of {@link Method} caches for the various instance method handlers. The index of
     * the array is the {@link Type#getSort()}.
     */
    private static final Method[] INSTANCE_HANDLERS = new Method[11];
    static
    {
        NativeInterceptingMethodAdapter.INSTANCE_HANDLERS[Type.OBJECT] =
            Method.getMethod("Object handleObject(Object,Class,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.INSTANCE_HANDLERS[Type.ARRAY] =
            NativeInterceptingMethodAdapter.INSTANCE_HANDLERS[Type.OBJECT];
        NativeInterceptingMethodAdapter.INSTANCE_HANDLERS[Type.BOOLEAN] =
            Method.getMethod("boolean handleBoolean(Object,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.INSTANCE_HANDLERS[Type.BYTE] =
            Method.getMethod("byte handleByte(Object,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.INSTANCE_HANDLERS[Type.CHAR] =
            Method.getMethod("char handleChar(Object,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.INSTANCE_HANDLERS[Type.DOUBLE] =
            Method.getMethod("double handleDouble(Object,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.INSTANCE_HANDLERS[Type.FLOAT] =
            Method.getMethod("float handleFloat(Object,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.INSTANCE_HANDLERS[Type.INT] =
            Method.getMethod("int handleInt(Object,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.INSTANCE_HANDLERS[Type.LONG] =
            Method.getMethod("long handleLong(Object,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.INSTANCE_HANDLERS[Type.SHORT] =
            Method.getMethod("short handleShort(Object,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.INSTANCE_HANDLERS[Type.VOID] =
            Method.getMethod("void handleVoid(Object,String,Class[],Object[])");
    }

    /**
     * An array of {@link Method} caches for the various static method handlers. The index of
     * the array is the {@link Type#getSort()}.
     */
    private static final Method[] STATIC_HANDLERS = new Method[11];
    static
    {
        NativeInterceptingMethodAdapter.STATIC_HANDLERS[Type.OBJECT] =
            Method.getMethod("Object handleStaticObject(Class,Class,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.STATIC_HANDLERS[Type.ARRAY] =
            NativeInterceptingMethodAdapter.STATIC_HANDLERS[Type.OBJECT];
        NativeInterceptingMethodAdapter.STATIC_HANDLERS[Type.BOOLEAN] =
            Method.getMethod("boolean handleStaticBoolean(Class,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.STATIC_HANDLERS[Type.BYTE] =
            Method.getMethod("byte handleStaticByte(Class,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.STATIC_HANDLERS[Type.CHAR] =
            Method.getMethod("char handleStaticChar(Class,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.STATIC_HANDLERS[Type.DOUBLE] =
            Method.getMethod("double handleStaticDouble(Class,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.STATIC_HANDLERS[Type.FLOAT] =
            Method.getMethod("float handleStaticFloat(Class,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.STATIC_HANDLERS[Type.INT] =
            Method.getMethod("int handleStaticInt(Class,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.STATIC_HANDLERS[Type.LONG] =
            Method.getMethod("long handleStaticLong(Class,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.STATIC_HANDLERS[Type.SHORT] =
            Method.getMethod("short handleStaticShort(Class,String,Class[],Object[])");
        NativeInterceptingMethodAdapter.STATIC_HANDLERS[Type.VOID] =
            Method.getMethod("void handleStaticVoid(Class,String,Class[],Object[])");
    };

    /**
     * The parent {@link ClassAdapter} that created this adapter. This is used to indicate when
     * the method is actually transformed. This allows the {@link ClassFileTransformer} to return
     * null to indicate when no changes have been made (which enables a performance improvement).
     */
    private final NativeInterceptingClassAdapter parent;

    /**
     * Whether this method is an instance method (i.e. not static)
     */
    private final boolean instance;

    /**
     * The declaring type for this method.
     */
    private final Type type;

    /**
     * The name of this method.
     */
    private final String name;

    /**
     * The return type for this method.
     */
    private final Type returnType;

    /**
     * The types of the parameters for this method.
     */
    private final Type[] argTypes;

    /**
     * Any exceptions declared by this method.
     */
    private final Type[] exceptions;

    /**
     * Whether this method should transform the existing code. This is triggered by the presence
     * of the {@link WasNative} method.
     */
    private boolean shouldTransform = false;

    /**
     * Whether this method has already been trasnformed. This is triggered by the presence of the
     * {@link Intercepted}
     */
    private boolean transformed = false;

    /**
     * Create a new {@link NativeInterceptingMethodAdapter} to transform a possible wrapped native
     * method. When the method adapted is not a wrapped native method, this adapter should make no
     * changes.
     *
     * @param mv The adapted {@link MethodVisitor}.
     * @param parent The parent {@link ClassAdapter}.
     * @param type The declaring type.
     * @param access The modifiers on the method.
     * @param name The name of the method.
     * @param desc The descriptor of the method.
     * @param exceptions The exceptions throw by this method.
     */
    public NativeInterceptingMethodAdapter(final MethodVisitor mv, final NativeInterceptingClassAdapter parent,
                                           final Type type, final int access, final String name, final String desc, final String[] exceptions)
    {
        super(mv, access, name, desc);
        this.parent = parent;
        this.instance = (access & Opcodes.ACC_STATIC) == 0;
        this.type = type;
        this.name = name;
        this.returnType = Type.getReturnType(desc);
        this.argTypes = Type.getArgumentTypes(desc);
        this.exceptions = new Type[exceptions == null ? 2 : exceptions.length + 2];
        if (exceptions != null)
            for (int i = 0; i < exceptions.length; i++)
                this.exceptions[i] = Type.getType('L' + exceptions[i] + ';');
        // Add the implicit runtime exception and error
        this.exceptions[this.exceptions.length - 2] = Constants.RUNTIME_EXCEPTION_TYPE;
        this.exceptions[this.exceptions.length - 1] = Constants.ERROR_TYPE;
    }

    @Override
    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible)
    {
        if (Constants.WAS_NATIVE_DESCRIPTOR.equals(desc))
            this.shouldTransform = true;
        if (Constants.INTERCEPTED_DESCRIPTOR.equals(desc))
            this.transformed = true;
        return super.visitAnnotation(desc, visible);
    }

    @Override
    public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc)
    {
        // Return quickly if this method is annotated with this @Intercepted annotation or is not annotated
        // with the @WasNative annotation.
        if (this.transformed || !this.shouldTransform)
        {
            super.visitMethodInsn(opcode, owner, name, desc);
            return;
        }
        System.out.println("Transforming to intercept: " + this.type + '#' + this.name);
        // Tell the parent that the bytecode is modified to intercept the native method.
        this.parent.setIntercepted();
        // Add the @Intercepted annotation to indicate that the method is intercepted.
        super.visitAnnotation(Constants.INTERCEPTED_DESCRIPTOR, true);
        // Create the try/catch block around the intercepted invocation.
        final Label lstart = new Label();
        final Label lend = new Label();
        final Label lexc = new Label();
        super.visitTryCatchBlock(lstart, lend, lexc, Constants.THROWABLE_TYPE.getInternalName());
        // Mark the start of the try/catch block.
        super.mark(lstart);
        // If this is an instance method, load this, otherwise load the class onto the stack.
        if (this.instance)
            super.loadThis();
        else
            super.visitLdcInsn(this.type);
        // The handler method for Object takes an additional argument for the return type.
        if (this.returnType.getSort() == Type.ARRAY || this.returnType.getSort() == Type.OBJECT)
            super.visitLdcInsn(this.returnType);
        // Push the name of the method onto the stack.
        super.visitLdcInsn(this.name);
        // Push the length of the argumentTypes array onto the stack.
        super.push(this.argTypes.length);
        // Create the argumentTypes array on ths stack.
        super.newArray(Constants.CLASS_TYPE);
        // Add each of the argument types to the argumentTypes array.
        for (int i = 0; i < this.argTypes.length; i++)
        {
            // Dup the array reference onto the stack.
            super.dup();
            // Push the index into the array onto the stack.
            super.push(i);
            // Push the argumentType onto the stack.
            switch (this.argTypes[i].getSort())
            {
                // Object types can simply use LDC
                case Type.ARRAY:
                case Type.OBJECT:
                    super.visitLdcInsn(this.argTypes[i]);
                    break;
                // Primitive types need to be fetched from the static .TYPE reference on the
                // Wrapper type
                case Type.BOOLEAN:
                case Type.BYTE:
                case Type.CHAR:
                case Type.DOUBLE:
                case Type.FLOAT:
                case Type.INT:
                case Type.LONG:
                case Type.SHORT:
                case Type.VOID:
                    super.getStatic(Constants.WRAPPER_TYPES[this.argTypes[i].getSort()], "TYPE", Constants.CLASS_TYPE);
                    break;
            }
            // Store the argument type in the array.
            super.visitInsn(Opcodes.AASTORE);
        }
        // Push an Object array onto the stack containing all arguments.
        super.loadArgArray();
        // Call the static handler method.
        super.invokeStatic(Constants.HANDLER_TYPE,
            this.instance ? NativeInterceptingMethodAdapter.INSTANCE_HANDLERS[this.returnType.getSort()] :
                            NativeInterceptingMethodAdapter.STATIC_HANDLERS[this.returnType.getSort()]);
        // Mark the end of the try/catch block.
        super.mark(lend);
        // Create the finishing label
        final Label lfinish = new Label();
        // If all is well, goto the end and finish.
        super.goTo(lfinish);
        // Mark the beginning of the exception handling code.
        super.mark(lexc);
        // Figure out which local variable to assign to the exception
        final int exceptionVarIdx = this.instance ? 1 : 0;
        // Store the exception
        super.visitVarInsn(Opcodes.ASTORE, exceptionVarIdx);
        // Cycle through the exceptions to see if there is an exception type that can be re-thrown
        // Without violating the contract of the native method (i.e. either a declared exception
        // or a RuntimeException).
        for (Type exception : this.exceptions)
        {
            // Push the exception onto the stack.
            super.visitVarInsn(Opcodes.ALOAD, exceptionVarIdx);
            // Do the instanceof check.
            super.instanceOf(exception);
            // Create the label to jump to when instanceof is false.
            final Label lnotinstanceof = new Label();
            // Jump to that label if the instanceof is false.
            super.visitJumpInsn(Opcodes.IFEQ, lnotinstanceof);
            // Push the exception back onto the stack.
            super.visitVarInsn(Opcodes.ALOAD, exceptionVarIdx);
            // Cast it.
            super.checkCast(exception);
            // Throw it.
            super.throwException();
            // Mark the jump target when not equal.
            super.mark(lnotinstanceof);
        }
        // Create a new IllegalStateException to throw indicating that an undeclared exception
        // Was thrown by the method handler (violating the contract).
        super.newInstance(Constants.ILLEGAL_STATE_EXCEPTION_TYPE);
        // Dup the exception
        super.dup();
        // Push the error message onto the stack
        super.push("Unexpected exception thrown in interceptor");
        // Push the illegal thrown exception onto the stack
        super.visitVarInsn(Opcodes.ALOAD, exceptionVarIdx);
        // Call the String,Throwable constructor.
        super.invokeConstructor(Constants.ILLEGAL_STATE_EXCEPTION_TYPE, Method.getMethod("void <init> (String,Throwable)"));
        // Throw the exception
        super.throwException();
        // Mark the finish jump target for the method.
        super.mark(lfinish);
        // If the return type is an object, cast it to the appropriate type prior to return.
        if (this.returnType.getSort() == Type.ARRAY ||
            this.returnType.getSort() == Type.OBJECT)
            super.checkCast(this.returnType);
        // Return the value returned by the handler method.
        super.returnValue();
        // Give ASM the chance to compute the max stack size.
        super.visitMaxs(0, 0);
    }

    // Since the visitMethodInsn method creates all instructions other than visitCode and visitEnd,
    // override all other visitor methods to act as a no-op when transforming;
    @Override
    public void visitInsn(final int opcode)
    {
        if (this.shouldTransform)
            return;
        super.visitInsn(opcode);
    }

    @Override
    public void visitLineNumber(final int line, final Label start)
    {
        if (this.shouldTransform)
            return;
        super.visitLineNumber(line, start);
    }

    @Override
    public void visitAttribute(final Attribute attr)
    {
        if (this.shouldTransform)
            return;
        super.visitAttribute(attr);
    }

    @Override
    public void visitFieldInsn(final int opcode, final String owner, final String name, final String desc)
    {
        if (this.shouldTransform)
            return;
        super.visitFieldInsn(opcode, owner, name, desc);
    }

    @Override
    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack)
    {
        if (this.shouldTransform)
            return;
        super.visitFrame(type, nLocal, local, nStack, stack);
    }

    @Override
    public void visitIincInsn(final int var, final int increment)
    {
        if (this.shouldTransform)
            return;
        super.visitIincInsn(var, increment);
    }

    @Override
    public void visitIntInsn(final int opcode, final int operand)
    {
        if (this.shouldTransform)
            return;
        super.visitIntInsn(opcode, operand);
    }

    @Override
    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start,
                                   final Label end, final int index)
    {
        if (this.shouldTransform)
            return;
        super.visitLocalVariable(name, desc, signature, start, end, index);
    }

    @Override
    public void visitMaxs(final int maxStack, final int maxLocals)
    {
        if (this.shouldTransform)
            return;
        super.visitMaxs(maxStack, maxLocals);
    }

    @Override
    public void visitVarInsn(final int opcode, final int var)
    {
        if (this.shouldTransform)
            return;
        super.visitVarInsn(opcode, var);
    }

    @Override
    public void visitJumpInsn(final int opcode, final Label label)
    {
        if (this.shouldTransform)
            return;
        super.visitJumpInsn(opcode, label);
    }

    @Override
    public void visitLabel(final Label label)
    {
        if (this.shouldTransform)
            return;
        super.visitLabel(label);
    }

    @Override
    public void visitLdcInsn(final Object cst)
    {
        if (this.shouldTransform)
            return;
        super.visitLdcInsn(cst);
    }

    @Override
    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels)
    {
        if (this.shouldTransform)
            return;
        super.visitLookupSwitchInsn(dflt, keys, labels);
    }

    @Override
    public void visitMultiANewArrayInsn(final String desc, final int dims)
    {
        if (this.shouldTransform)
            return;
        super.visitMultiANewArrayInsn(desc, dims);
    }

    @Override
    public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label[] labels)
    {
        if (this.shouldTransform)
            return;
        super.visitTableSwitchInsn(min, max, dflt, labels);
    }

    @Override
    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type)
    {
        if (this.shouldTransform)
            return;
        super.visitTryCatchBlock(start, end, handler, type);
    }

    @Override
    public void visitTypeInsn(final int opcode, final String type)
    {
        if (this.shouldTransform)
            return;
        super.visitTypeInsn(opcode, type);
    }
}